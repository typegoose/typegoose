"use strict";(self.webpackChunktypegoose_website=self.webpackChunktypegoose_website||[]).push([[3943],{6379:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>a});const o=JSON.parse('{"id":"guides/advanced/reference-other-classes","title":"Reference other Classes","description":"Look here for the Ref type documentation","source":"@site/../docs/guides/advanced/reference-other-classes.md","sourceDirName":"guides/advanced","slug":"/guides/advanced/reference-other-classes","permalink":"/typegoose/versions/beta/docs/guides/advanced/reference-other-classes","draft":false,"unlisted":false,"editUrl":"https://github.com/typegoose/typegoose/edit/beta/docs/../docs/guides/advanced/reference-other-classes.md","tags":[],"version":"current","frontMatter":{"id":"reference-other-classes","title":"Reference other Classes"},"sidebar":"guides","previous":{"title":"Models with same name","permalink":"/typegoose/versions/beta/docs/guides/advanced/models-with-same-name"},"next":{"title":"Change _id Type","permalink":"/typegoose/versions/beta/docs/guides/advanced/change-id-type"}}');var t=s(4848),r=s(8453);const i={id:"reference-other-classes",title:"Reference other Classes"},d=void 0,c={},a=[{value:"Referencing other Classes",id:"referencing-other-classes",level:2},{value:"Reference other classes with different _id type",id:"reference-other-classes-with-different-_id-type",level:3},{value:"Population",id:"population",level:2},{value:"Common Problems",id:"common-problems",level:2},{value:"Circular Dependencies",id:"circular-dependencies",level:3}];function l(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.a,{href:"/typegoose/versions/beta/docs/api/types/ref-type",children:["Look here for the ",(0,t.jsx)(n.code,{children:"Ref"})," type documentation"]})}),"\n",(0,t.jsx)(n.h2,{id:"referencing-other-classes",children:"Referencing other Classes"}),"\n",(0,t.jsx)(n.p,{children:"Referencing other classes may be needed to create relationships, this can be done with the following:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"class Nested {\n  @prop()\n  public someNestedProperty: string;\n}\n\nclass Main {\n  @prop({ ref: () => Nested }) // for one\n  public nested: Ref<Nested>;\n\n  @prop({ ref: () => Nested }) // for an array of references\n  public nestedArray: Ref<Nested>[];\n}\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["Options ",(0,t.jsx)(n.code,{children:"ref"})," and ",(0,t.jsx)(n.code,{children:"type"})," can both also be defined without ",(0,t.jsx)(n.code,{children:"() =>"}),", but is generally recommended to be used with.",(0,t.jsx)(n.br,{}),"\n","If ",(0,t.jsx)(n.code,{children:"() =>"})," is not used, there can be problems when the class (/ variable) is defined ",(0,t.jsx)(n.em,{children:"after"})," the decorator that requires it."]})}),"\n",(0,t.jsx)(n.h3,{id:"reference-other-classes-with-different-_id-type",children:"Reference other classes with different _id type"}),"\n",(0,t.jsxs)(n.p,{children:["Sometimes the ",(0,t.jsx)(n.code,{children:"_id"})," type needs to be changed (to something like ",(0,t.jsx)(n.code,{children:"String"})," / ",(0,t.jsx)(n.code,{children:"Number"}),") and needs to be manually defined in the reference:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"class Cat {\n  @prop()\n  public _id: string;\n\n  @prop()\n  public year: number;\n}\n\nclass Person {\n  @prop()\n  public name: string;\n\n  @prop({ ref: () => Cat, type: () => String })\n  public pet?: Ref<Cat, string>;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Also see ",(0,t.jsx)(n.a,{href:"/typegoose/versions/beta/docs/guides/advanced/change-id-type",children:"Change _id Type"}),"."]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["By default typegoose sets the default for the option ",(0,t.jsx)(n.code,{children:"type"})," (if not defined) to ",(0,t.jsx)(n.code,{children:"mongoose.Schema.Types.ObjectId"})]})}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["The option ",(0,t.jsx)(n.code,{children:"type"}),' is not automatically inferred at runtime, because this could cause more "Circular Dependency" issues.',(0,t.jsx)(n.br,{}),"\n","See ",(0,t.jsx)(n.a,{href:"#common-problems",children:"Common Problems"})," for more."]})}),"\n",(0,t.jsxs)(n.admonition,{type:"tip",children:[(0,t.jsxs)(n.p,{children:["The generic-parameter ",(0,t.jsx)(n.code,{children:"RawId"})," in ",(0,t.jsx)(n.a,{href:"/typegoose/versions/beta/docs/api/types/ref-type",children:(0,t.jsx)(n.code,{children:"Ref"})})," is automatically inferred if the ",(0,t.jsx)(n.code,{children:"PopulatedType"})," sets a ",(0,t.jsx)(n.code,{children:"_id"})," property that is in ",(0,t.jsx)(n.code,{children:"RefType"}),":"]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"class Cat {\n  @prop()\n  public _id: string;\n}\n\nclass Person {\n  @prop({ ref: () => Cat, type: () => String })\n  public pet?: Ref<Cat>;\n}\n"})}),(0,t.jsxs)(n.p,{children:["though remember that the ",(0,t.jsx)(n.code,{children:"type"})," options ",(0,t.jsx)(n.strong,{children:"still"})," needs to be set!"]})]}),"\n",(0,t.jsx)(n.h2,{id:"population",children:"Population"}),"\n",(0,t.jsx)(n.p,{children:"One of the main reasons why references may want to be used over plain types, is population, which can be done with:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'// this example continues to use the classes defined previously\n\nconst cat = await CatModel.create({ year: 2015 });\n\nawait PersonModel.create({ name: "Jonny", pet: cat });\n\nconst person1 = await PersonModel.findOne({ name: "Jonny" });\n// with this path "pet" is still unpopulated\nawait person1.populate("pet"); // will try to populate path "pet"\n\nconsole.log(person1.pet); // will list the populated data\n// but for actual use in the code it will need to be checked that it is actually populated, because ".populate" may also fail\nperson1.pet.year; // Type Error: "pet" may not have property "year"\n// for this the typeguard "isDocument" is used that typegoose provides\nif (isDocument(person1.pet)) {\n  person1.pet.year; // Works without typescript complaining\n} else {\n  // in this case the path is definitely NOT a document\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Function ",(0,t.jsx)(n.a,{href:"/typegoose/versions/beta/docs/api/functions/typeguards/is-document#isdocument",children:(0,t.jsx)(n.code,{children:"isDocument"})})," (or for arrays ",(0,t.jsx)(n.a,{href:"/typegoose/versions/beta/docs/api/functions/typeguards/is-document#isdocumentarray",children:(0,t.jsx)(n.code,{children:"isDocumentArray"})}),") will need to be used to narrow the type after population, because ",(0,t.jsx)(n.code,{children:".populate"})," may fail."]}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:["Populated paths are ",(0,t.jsx)(n.strong,{children:"not"})," subdocuments, they are their own top-level documents and modifications to them need to be saved separately.",(0,t.jsx)(n.br,{}),"\n","See ",(0,t.jsx)(n.a,{href:"https://mongoosejs.com/docs/subdocs.html",children:"Subdocuments"})," in mongoose's documentation."]})}),"\n",(0,t.jsx)(n.h2,{id:"common-problems",children:"Common Problems"}),"\n",(0,t.jsx)(n.p,{children:"Because of the order classes are loaded and reordered at runtime, this might result in some references being null / undefined / not existing. This is why Typegoose provides the following:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"class Nested {\n  @prop()\n  public someNestedProperty: string;\n}\n\n// Recommended first fix:\nclass Main {\n  @prop({ ref: () => Nested }) // since 7.1 arrow functions can be used to defer getting the type\n  public nested: Ref<Nested>;\n}\n\n// Not recommended workaround (hardcoding model name):\nclass Main {\n  @prop({ ref: 'Nested' }) // since 7.0 it is recommended to use \"console.log(getName(Class))\" to get the generated name once and hardcode it like shown here\n  public nested: Ref<Nested>;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"When you get errors about references, try making the name of the referenced class a string."}),"\n",(0,t.jsx)(n.admonition,{type:"warning",children:(0,t.jsxs)(n.p,{children:["The new ",(0,t.jsx)(n.code,{children:"() => Class"})," is meant to help with Circular Dependencies, but cannot remove the problems in all cases, see ",(0,t.jsx)(n.a,{href:"#circular-dependencies",children:"Circular Dependencies"})," for more."]})}),"\n",(0,t.jsx)(n.h3,{id:"circular-dependencies",children:"Circular Dependencies"}),"\n",(0,t.jsxs)(n.p,{children:["As an warning in ",(0,t.jsx)(n.a,{href:"#common-problems",children:"Common Problems"})," already said, the ",(0,t.jsx)(n.code,{children:"() => Class"})," way can help with circular dependencies, but not remove them, this is due to how javascript works."]}),"\n",(0,t.jsx)(n.p,{children:"The only known way to resolve the remaining problems, are to do something like to following to all class and model files:"}),"\n",(0,t.jsxs)(n.p,{children:["Remove the following from File ",(0,t.jsx)(n.code,{children:"A"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-diff",children:'import { B } from "./B";\n\nexport class A {\n  @prop()\n  public name: string;\n\n  @prop({ ref: () => B })\n  public b: Ref<B>;\n}\n\n- export const AModel = getModelForClass(A);\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Remove the following from File ",(0,t.jsx)(n.code,{children:"B"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-diff",children:'import { A } from "./A";\n\nexport class B {\n  @prop()\n  public name: string;\n\n  @prop({ ref: () => A })\n  public a: Ref<A>;\n}\n\n- export const BModel = getModelForClass(B);\n'})}),"\n",(0,t.jsx)(n.p,{children:"And Add a central processing file:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-diff",children:'+ import { A } from "./A";\n+ import { B } from "./B";\n+ \n+ export const AModel = getModelForClass(A);\n+ export const BModel = getModelForClass(B);\n'})}),"\n",(0,t.jsxs)(n.p,{children:["This may seem like it is not changing much, but actually nodejs will resolve & load all required imports fully before trying to use any of them.",(0,t.jsx)(n.br,{}),"\n","And because the ",(0,t.jsx)(n.code,{children:"() => Class"})," way is used, the reference to ",(0,t.jsx)(n.code,{children:"Class"})," will only be resolved once the function is actually called, that is why this method works, but just ",(0,t.jsx)(n.code,{children:"Class"})," doesn't."]}),"\n",(0,t.jsxs)(n.p,{children:["To find Circular dependencies, you can use tools like ",(0,t.jsx)(n.a,{href:"https://www.npmjs.com/package/dpdm",children:(0,t.jsx)(n.code,{children:"dpdm"})})," or ",(0,t.jsx)(n.a,{href:"https://www.npmjs.com/package/madge",children:(0,t.jsx)(n.code,{children:"madge"})}),"."]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>d});var o=s(6540);const t={},r=o.createContext(t);function i(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);