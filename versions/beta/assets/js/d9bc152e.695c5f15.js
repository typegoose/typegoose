"use strict";(self.webpackChunktypegoose_website=self.webpackChunktypegoose_website||[]).push([[7342],{2803:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"guides/advanced/overwrite-this","title":"Why overwrite \\"this\\"","description":"In the documentation for typegoose you may have already seen the following and asked \\"Why do i need to overwrite this\\"?","source":"@site/../docs/guides/advanced/overwrite-this.md","sourceDirName":"guides/advanced","slug":"/guides/advanced/overwrite-this","permalink":"/typegoose/versions/beta/docs/guides/advanced/overwrite-this","draft":false,"unlisted":false,"editUrl":"https://github.com/typegoose/typegoose/edit/beta/docs/../docs/guides/advanced/overwrite-this.md","tags":[],"version":"current","frontMatter":{"id":"overwrite-this","title":"Why overwrite \\"this\\""},"sidebar":"guides","previous":{"title":"Manual Schema Modification","permalink":"/typegoose/versions/beta/docs/guides/advanced/manual-schema-modification"},"next":{"title":"Migrate to 12.0.0","permalink":"/typegoose/versions/beta/docs/guides/migration/migrate-12"}}');var s=n(4848),o=n(8453);const r={id:"overwrite-this",title:'Why overwrite "this"'},c=void 0,a={},d=[{value:"Reason for overwriting",id:"reason-for-overwriting",level:2},{value:"Typescript Notes",id:"typescript-notes",level:2},{value:"Difference between value and type",id:"difference-between-value-and-type",level:3}];function l(e){const t={a:"a",br:"br",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:['In the documentation for typegoose you may have already seen the following and asked "Why do i need to overwrite ',(0,s.jsx)(t.code,{children:"this"}),'"?']}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:'class Kitten {\n  // Note the following "this"\n  public goEat(this: DocumentType<Kitten>, where: string) {\n    // ...code to eat\n  }\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"reason-for-overwriting",children:"Reason for overwriting"}),"\n",(0,s.jsxs)(t.p,{children:["The reason would be that by default the type would implicitly be ",(0,s.jsx)(t.code,{children:"this: Kitten"}),"(instance), which does not give access to the document functions and would also be the wrong type and so could wrongly assume ",(0,s.jsx)(t.code,{children:"this instanceof Kitten"})," would work, whereas that would not actually be true."]}),"\n",(0,s.jsxs)(t.p,{children:["For Instance methods the implicit type would be ",(0,s.jsx)(t.code,{children:"this: Kitten"}),"(instance), whereas the correct type would be ",(0,s.jsx)(t.code,{children:"this: DocumentType<Kitten>"}),".",(0,s.jsx)(t.br,{}),"\n","For Static methods the implicit type would be ",(0,s.jsx)(t.code,{children:"this: typeof Kitten"}),"(static), whereas the correct type would be ",(0,s.jsx)(t.code,{children:"this: ReturnModelType<typeof Kitten>"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["The same also applies to other places like validators or QueryHelpers where the ",(0,s.jsx)(t.code,{children:"this"})," may need to be overwritten."]}),"\n",(0,s.jsx)(t.h2,{id:"typescript-notes",children:"Typescript Notes"}),"\n",(0,s.jsx)(t.p,{children:"This section has some typescript notes that are subtle and can cause confusion."}),"\n",(0,s.jsx)(t.h3,{id:"difference-between-value-and-type",children:"Difference between value and type"}),"\n",(0,s.jsxs)(t.p,{children:["The Type ",(0,s.jsx)(t.code,{children:"Kitten"})," is not, infact, the class ",(0,s.jsx)(t.code,{children:"Kitten"})," but the ",(0,s.jsx)(t.em,{children:"instance"})," of ",(0,s.jsx)(t.code,{children:"Kitten"}),", to actually get the static you would need to do ",(0,s.jsx)(t.code,{children:"typeof Kitten"}),".\nIf you would ever need to get the ",(0,s.jsx)(t.em,{children:"instance"}),"(",(0,s.jsx)(t.code,{children:"Kitten"}),") type of a class while you only have the input of a ",(0,s.jsx)(t.em,{children:"static"}),"(",(0,s.jsx)(t.code,{children:"typeof Kitten"}),"), there is a Typescript Utility Type called ",(0,s.jsx)(t.a,{href:"https://www.typescriptlang.org/docs/handbook/utility-types.html#instancetypetype",children:(0,s.jsx)(t.code,{children:"InstanceType"})}),". (Which was also the reason why typegoose had to rename its ",(0,s.jsxs)(t.a,{href:"../migration/migrate-6#instancetype-changed",children:[(0,s.jsx)(t.code,{children:"InstanceType"})," to ",(0,s.jsx)(t.code,{children:"DocumentType"})]}),")"]}),"\n",(0,s.jsx)(t.p,{children:"Example:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:'class Kitten {\n  public dummy?: string;\n}\n\n// the two basic differences, static & instance:\n\n// T1 & T2 are "typeof Kitten" (static Kitten) and are interchangeable definitions\nconst T1 = Kitten;\n// explicit type\nconst T2: typeof Kitten = Kitten;\n\n// T3 & T4 are "Kitten" (instance of Kitten) and are interchangeable definitions\nconst T3 = new Kitten();\n// explicit type\nconst T4: Kitten = new Kitten();\n\n// combinations & errors\n\n// T5 & T6 are "Kitten" (instance of Kitten), whereas the assigned value of T5 is "typeof Kitten" (static Kitten)\nconst T5: Kitten = Kitten; // Error: Value of type \'typeof Kitten\' has no properties in common with type \'Kitten\'. Did you mean to call it?\nconst T6: Kitten = new Kitten(); // this is actually the correct type\n\n// T7 is "typeof Kitten" (static Kitten), and assigned is a "Kitten" (instance of Kitten)\nconst T7: typeof Kitten = new Kitten(); // Error: Property \'prototype\' is missing in type \'Kitten\' but required in type \'typeof Kitten\'\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Also note that the rules slightly change if the class is ",(0,s.jsx)(t.em,{children:"empty"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:'class Kitten {}\n\n// the two basic differences, static & instance:\n\n// T1 & T2 are "typeof Kitten" (static Kitten)\nconst T1 = Kitten;\n// explicit type\nconst T2: typeof Kitten = Kitten;\n\n// T3 & T4 are "Kitten" (instance of Kitten)\nconst T3 = new Kitten();\n// explicit type\nconst T4: Kitten = new Kitten();\n\n// combinations & errors\n\n// DIFFERENCE\n// T5 & T6 are "Kitten" (instance of Kitten), whereas the assigned value of T5 is "typeof Kitten" (static Kitten)\nconst T5: Kitten = Kitten; // somehow this does not result in any error\nconst T6: Kitten = new Kitten(); // this is actually the correct type\n\n// T7 is "typeof Kitten" (static Kitten), and assigned is a "Kitten" (instance of Kitten)\nconst T7: typeof Kitten = new Kitten(); // Error: Property \'prototype\' is missing in type \'Kitten\' but required in type \'typeof Kitten\'\n'})})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>c});var i=n(6540);const s={},o=i.createContext(s);function r(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);