"use strict";(self.webpackChunktypegoose_website=self.webpackChunktypegoose_website||[]).push([[7215],{5680:(e,n,t)=>{t.d(n,{xA:()=>c,yg:()=>y});var i=t(6540);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=i.createContext({}),d=function(e){var n=i.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},c=function(e){var n=d(e.components);return i.createElement(l.Provider,{value:n},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},m=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=d(t),m=a,y=u["".concat(l,".").concat(m)]||u[m]||p[m]||r;return t?i.createElement(y,o(o({ref:n},c),{},{components:t})):i.createElement(y,o({ref:n},c))}));function y(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,o=new Array(r);o[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[u]="string"==typeof e?e:a,o[1]=s;for(var d=2;d<r;d++)o[d]=t[d];return i.createElement.apply(null,o)}return i.createElement.apply(null,t)}m.displayName="MDXCreateElement"},9365:(e,n,t)=>{t.d(n,{A:()=>o});var i=t(6540),a=t(53);const r={tabItem:"tabItem_Ymn6"};function o(e){let{children:n,hidden:t,className:o}=e;return i.createElement("div",{role:"tabpanel",className:(0,a.A)(r.tabItem,o),hidden:t},n)}},1470:(e,n,t)=>{t.d(n,{A:()=>M});var i=t(8168),a=t(6540),r=t(53),o=t(3104),s=t(6347),l=t(7485),d=t(1682),c=t(9466);function u(e){return function(e){var n,t;return null!=(n=null==(t=a.Children.map(e,(e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})))?void 0:t.filter(Boolean))?n:[]}(e).map((e=>{let{props:{value:n,label:t,attributes:i,default:a}}=e;return{value:n,label:t,attributes:i,default:a}}))}function p(e){const{values:n,children:t}=e;return(0,a.useMemo)((()=>{const e=null!=n?n:u(t);return function(e){const n=(0,d.X)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error('Docusaurus error: Duplicate values "'+n.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[n,t])}function m(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function y(e){let{queryString:n=!1,groupId:t}=e;const i=(0,s.W6)(),r=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=t?t:null}({queryString:n,groupId:t});return[(0,l.aZ)(r),(0,a.useCallback)((e=>{if(!r)return;const n=new URLSearchParams(i.location.search);n.set(r,e),i.replace({...i.location,search:n.toString()})}),[r,i])]}function g(e){const{defaultValue:n,queryString:t=!1,groupId:i}=e,r=p(e),[o,s]=(0,a.useState)((()=>function(e){var n;let{defaultValue:t,tabValues:i}=e;if(0===i.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:i}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+t+'" but none of its children has the corresponding value. Available values are: '+i.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return t}const a=null!=(n=i.find((e=>e.default)))?n:i[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:r}))),[l,d]=y({queryString:t,groupId:i}),[u,g]=function(e){let{groupId:n}=e;const t=function(e){return e?"docusaurus.tab."+e:null}(n),[i,r]=(0,c.Dv)(t);return[i,(0,a.useCallback)((e=>{t&&r.set(e)}),[t,r])]}({groupId:i}),h=(()=>{const e=null!=l?l:u;return m({value:e,tabValues:r})?e:null})();(0,a.useLayoutEffect)((()=>{h&&s(h)}),[h]);return{selectedValue:o,selectValue:(0,a.useCallback)((e=>{if(!m({value:e,tabValues:r}))throw new Error("Can't select invalid tab value="+e);s(e),d(e),g(e)}),[d,g,r]),tabValues:r}}var h=t(2303);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function b(e){let{className:n,block:t,selectedValue:s,selectValue:l,tabValues:d}=e;const c=[],{blockElementScrollPositionUntilNextRender:u}=(0,o.a_)(),p=e=>{const n=e.currentTarget,t=c.indexOf(n),i=d[t].value;i!==s&&(u(n),l(i))},m=e=>{var n;let t=null;switch(e.key){case"Enter":p(e);break;case"ArrowRight":{var i;const n=c.indexOf(e.currentTarget)+1;t=null!=(i=c[n])?i:c[0];break}case"ArrowLeft":{var a;const n=c.indexOf(e.currentTarget)-1;t=null!=(a=c[n])?a:c[c.length-1];break}}null==(n=t)||n.focus()};return a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":t},n)},d.map((e=>{let{value:n,label:t,attributes:o}=e;return a.createElement("li",(0,i.A)({role:"tab",tabIndex:s===n?0:-1,"aria-selected":s===n,key:n,ref:e=>c.push(e),onKeyDown:m,onClick:p},o,{className:(0,r.A)("tabs__item",f.tabItem,null==o?void 0:o.className,{"tabs__item--active":s===n})}),null!=t?t:n)})))}function v(e){let{lazy:n,children:t,selectedValue:i}=e;const r=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=r.find((e=>e.props.value===i));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return a.createElement("div",{className:"margin-top--md"},r.map(((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==i}))))}function w(e){const n=g(e);return a.createElement("div",{className:(0,r.A)("tabs-container",f.tabList)},a.createElement(b,(0,i.A)({},e,n)),a.createElement(v,(0,i.A)({},e,n)))}function M(e){const n=(0,h.A)();return a.createElement(w,(0,i.A)({key:String(n)},e))}},8532:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>y,frontMatter:()=>s,metadata:()=>d,toc:()=>u});var i=t(8168),a=(t(6540),t(5680)),r=t(1470),o=t(9365);const s={id:"nested-discriminators",title:"Nested Discriminators"},l=void 0,d={unversionedId:"guides/advanced/nested-discriminators",id:"guides/advanced/nested-discriminators",title:"Nested Discriminators",description:"Use-Case",source:"@site/../docs/guides/advanced/nested-discriminators.mdx",sourceDirName:"guides/advanced",slug:"/guides/advanced/nested-discriminators",permalink:"/typegoose/versions/beta/docs/guides/advanced/nested-discriminators",draft:!1,editUrl:"https://github.com/typegoose/typegoose/edit/beta/docs/../docs/guides/advanced/nested-discriminators.mdx",tags:[],version:"current",frontMatter:{id:"nested-discriminators",title:"Nested Discriminators"},sidebar:"guides",previous:{title:"Non-Nested Discriminators",permalink:"/typegoose/versions/beta/docs/guides/advanced/non-nested-discriminators"},next:{title:"Typegoose's Name Generation",permalink:"/typegoose/versions/beta/docs/guides/advanced/name-generation"}},c={},u=[{value:"Use-Case",id:"use-case",level:2},{value:"First thought",id:"first-thought",level:2},{value:"Fixing it with Nested Discriminators",id:"fixing-it-with-nested-discriminators",level:2},{value:"Extras",id:"extras",level:2},{value:"Multiple ways to define nested discriminators",id:"multiple-ways-to-define-nested-discriminators",level:3},{value:"See Also",id:"see-also",level:2}],p={toc:u},m="wrapper";function y(e){let{components:n,...t}=e;return(0,a.yg)(m,(0,i.A)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.yg)("h2",{id:"use-case"},"Use-Case"),(0,a.yg)("p",null,"If you don't know an use case for this, consider the following:",(0,a.yg)("br",{parentName:"p"}),"\n","A Veterinarian that wants to store medication information about the current patients in their care, how would it be done in mongoose / typegoose?"),(0,a.yg)("admonition",{type:"note"},(0,a.yg)("p",{parentName:"admonition"},"This Guide will use similar examples and guide style to that from ",(0,a.yg)("a",{parentName:"p",href:"/typegoose/versions/beta/docs/guides/advanced/non-nested-discriminators"},"Non-Nested-Discriminators"),".")),(0,a.yg)("admonition",{type:"note"},(0,a.yg)("p",{parentName:"admonition"},'Nested Discriminators may also be called "Embedded Discriminators".')),(0,a.yg)("admonition",{type:"info"},(0,a.yg)("p",{parentName:"admonition"},"This Guide will use the ",(0,a.yg)("a",{parentName:"p",href:"/typegoose/versions/beta/docs/api/functions/assertions"},(0,a.yg)("inlineCode",{parentName:"a"},"assertion"))," function that typegoose provides.",(0,a.yg)("br",{parentName:"p"}),"\n","TL;DR: This function is basically like NodeJS's ",(0,a.yg)("a",{parentName:"p",href:"https://nodejs.org/api/assert.html#assertvalue-message"},(0,a.yg)("inlineCode",{parentName:"a"},"assert")),", just more typescript friendly.")),(0,a.yg)("h2",{id:"first-thought"},"First thought"),(0,a.yg)("p",null,"At first you might think to do a basic array, that is of type ",(0,a.yg)("inlineCode",{parentName:"p"},"Mixed"),":"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'interface MedicationA {\n  name: string;\n  amount: number;\n}\n\ninterface MedicationB {\n  name: string;\n  length: number;\n}\n\nclass Animal {\n  @prop({ required: true, unique: true })\n  public patientNumber!: number;\n\n  // Even when not setting the type explicitly, the resulting type would be "Mixed" with the typescript type below\n  @prop({ type: mongoose.Schema.Types.Mixed })\n  public medications?: (MedicationA | MedicationB)[];\n}\n\nconst AnimalModel = getModelForClass(Animal);\n')),(0,a.yg)("p",null,"And then in some code accessing the properties:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},"const doc = await AnimalModel.create({\n  patientNumber: 0,\n  medications: [\n    {\n      name: 'med1',\n      amount: 10,\n    } as MedicationA,\n    {\n      name: 'med2',\n      length: 5,\n    } as MedicationB,\n    {\n      unknownType: 1,\n    },\n  ],\n});\n\nassertion(doc.medications[0].name === 'med1');\nassertion(doc.medications[1].name === 'med2');\nassertion(doc.medications[2].unknownType === 1);\nassertion(doc.medications.length === 3);\n")),(0,a.yg)("p",null,"Which is obviously problematic:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"No Runtime validation and no Middleware applied to elements of the array (because of type ",(0,a.yg)("inlineCode",{parentName:"li"},"Mixed"),")"),(0,a.yg)("li",{parentName:"ul"},"Because of no validation, unknown properties like ",(0,a.yg)("inlineCode",{parentName:"li"},"unknownType")," will persist")),(0,a.yg)("h2",{id:"fixing-it-with-nested-discriminators"},"Fixing it with Nested Discriminators"),(0,a.yg)("p",null,"The code from ",(0,a.yg)("a",{parentName:"p",href:"#first-thought"},"First thought")," is not that far off of what nested discriminators will need to work:"),(0,a.yg)(r.A,{groupId:"diff-full",mdxType:"Tabs"},(0,a.yg)(o.A,{value:"diff",label:"Difference",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-diff"},"+ @modelOptions({\n+   schemaOptions: {\n+     // Set the property key which is used to discriminate between the different types\n+     discriminatorKey: 'name',\n+     // Disable automatic \"_id\" property\n+     _id: false,\n+   },\n+ })\n+ class MedicationBase {\n+   @prop({ required: true })\n+   public name!: string;\n+ }\n\n+ enum MedicationTypes {\n+   MedicationA = 'MedicationA',\n+   MedicationB = 'MedicationB',\n+ }\n\n- interface MedicationA {\n-   name: string;\n-   amount: number;\n+ class MedicationA extends MedicationBase {\n+   @prop({ required: true })\n+   public amount!: number;\n}\n\n- interface MedicationB {\n-   name: string;\n-   length: number;\n+ class MedicationB extends MedicationBase {\n+   @prop({ required: true })\n+   public length!: number;\n}\n\nclass Animal {\n  @prop({ required: true, unique: true })\n  public patientNumber!: number;\n\n-   // Even when not setting the type explicitly, the resulting type would be \"Mixed\" with the typescript type below\n-   @prop({ type: mongoose.Schema.Types.Mixed })\n-   public medications?: (MedicationA | MedicationB)[];\n+   @prop({\n+     required: true,\n+     // Set the Base class, which all types need to extend from\n+     type: MedicationBase,\n+     // Set the nested discriminators that are used for this property\n+     discriminators: () => [\n+       // The \"advanced\" way of defining types is used here, to make it easier to understand\n+       { type: MedicationA, value: MedicationTypes.MedicationA },\n+       { type: MedicationB, value: MedicationTypes.MedicationB },\n+     ],\n+   })\n+   public medications!: MedicationBase[];\n}\n\nconst AnimalModel = getModelForClass(Animal);\n"))),(0,a.yg)(o.A,{value:"fullcode",label:"Full Code",default:!0,mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},"@modelOptions({\n  schemaOptions: {\n    // Set the property key which is used to discriminate between the different types\n    discriminatorKey: 'name',\n    // Disable automatic \"_id\" property\n    _id: false,\n  },\n})\nclass MedicationBase {\n  @prop({ required: true })\n  public name!: string;\n}\n\n// A Enum is used to easily keep track of different types, instead of hardcoding it in many places\nenum MedicationTypes {\n  MedicationA = 'MedicationA',\n  MedicationB = 'MedicationB',\n}\n\nclass MedicationA extends MedicationBase {\n  @prop({ required: true })\n  public amount!: number;\n}\n\nclass MedicationB extends MedicationBase {\n  @prop({ required: true })\n  public length!: number;\n}\n\nclass Animal {\n  @prop({ required: true, unique: true })\n  public patientNumber!: number;\n\n  @prop({\n    required: true,\n    // Set the Base class, which all types need to extend from\n    type: MedicationBase,\n    // Set the nested discriminators that are used for this property\n    discriminators: () => [\n      // The \"advanced\" way of defining types is used here, to make it easier to understand, see section #Extras\n      { type: MedicationA, value: MedicationTypes.MedicationA },\n      { type: MedicationB, value: MedicationTypes.MedicationB },\n    ],\n  })\n  public medications!: MedicationBase[];\n}\n\nconst AnimalModel = getModelForClass(Animal);\n")))),(0,a.yg)("p",null,"And then in some code accessing the properties again:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},"const doc = await AnimalModel.create({\n  patientNumber: 1,\n  medications: [\n    {\n      name: MedicationTypes.MedicationA,\n      amount: 10,\n    } as MedicationA,\n    {\n      name: MedicationTypes.MedicationB,\n      length: 5,\n    } as MedicationB,\n  ],\n});\n\ntry {\n  await AnimalModel.create({\n    patientNumber: 2,\n    medications: [\n      {\n        unknownType: 1,\n      },\n    ],\n  });\n\n  throw new Error('Expected create to fail');\n} catch (err) {\n  assertion(err instanceof mongoose.Error.ValidationError);\n}\n\nassertion(doc.medications[0].name === MedicationTypes.MedicationA);\nassertion(doc.medications[1].name === MedicationTypes.MedicationB);\nassertion(doc.medications.length === 2);\n")),(0,a.yg)("p",null,"This Time, it will correctly validate and apply middleware to all elements of the array, meaning it will correctly strip all unknown elements and error if elements are missing (as can be seen in the ",(0,a.yg)("inlineCode",{parentName:"p"},"try-catch"),")."),(0,a.yg)("h2",{id:"extras"},"Extras"),(0,a.yg)("h3",{id:"multiple-ways-to-define-nested-discriminators"},"Multiple ways to define nested discriminators"),(0,a.yg)("p",null,"There are currently multiple ways to define nested discriminators, which are:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Directly and only the ",(0,a.yg)("inlineCode",{parentName:"li"},"Class")),(0,a.yg)("li",{parentName:"ul"},"A ",(0,a.yg)("inlineCode",{parentName:"li"},"DiscriminatorObject")," (which is used in the examples)")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'class Animal {\n  @prop({\n    type: MedicationBase,\n    // Define nested discriminators with a "DiscriminatorObject"\n    // Explicitly set the discriminator value\n    discriminators: () => [\n      { type: MedicationA, value: MedicationTypes.MedicationA },\n      { type: MedicationB, value: MedicationTypes.MedicationB },\n    ],\n    // Define nested discriminators with the "Class" directly\n    // Implicitly converts the generated model name to the discriminator value\n    discriminators: () => [\n      MedicationA,\n      MedicationB,\n    ],\n  })\n  public medications!: MedicationBase[];\n}\n')),(0,a.yg)("p",null,"See ",(0,a.yg)("inlineCode",{parentName:"p"},"@prop")," option ",(0,a.yg)("a",{parentName:"p",href:"/typegoose/versions/beta/docs/api/decorators/prop#discriminators"},(0,a.yg)("inlineCode",{parentName:"a"},"discriminators")),"."),(0,a.yg)("h2",{id:"see-also"},"See Also"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Also see the blog post from ",(0,a.yg)("inlineCode",{parentName:"li"},"thecodebarbarian")," (or also known as ",(0,a.yg)("inlineCode",{parentName:"li"},"vkarpov15")," on github) about ",(0,a.yg)("a",{parentName:"li",href:"https://thecodebarbarian.com/mongoose-4.12-single-embedded-discriminators.html"},"Embedded Discriminators"),".")))}y.isMDXComponent=!0}}]);