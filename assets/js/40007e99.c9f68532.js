"use strict";(self.webpackChunktypegoose_website=self.webpackChunktypegoose_website||[]).push([[7029],{5468:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>i,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"guides/syntax-notes","title":"Syntax Notes","description":"This Page shows different possibilities of how code can be written in Typegoose, along with their use-cases and what differs between them.","source":"@site/../docs/guides/syntax-notes.md","sourceDirName":"guides","slug":"/guides/syntax-notes","permalink":"/typegoose/docs/guides/syntax-notes","draft":false,"unlisted":false,"editUrl":"https://github.com/typegoose/typegoose/edit/master/docs/../docs/guides/syntax-notes.md","tags":[],"version":"current","frontMatter":{"id":"syntax-notes","title":"Syntax Notes"},"sidebar":"guides","previous":{"title":"Error & Warning Details","permalink":"/typegoose/docs/guides/error-warning-details"},"next":{"title":"Using with class-transformer","permalink":"/typegoose/docs/guides/integration-examples/using-with-class-transformer"}}');var r=n(4848),s=n(8453);const i={id:"syntax-notes",title:"Syntax Notes"},a=void 0,c={},d=[{value:"<code>type</code> &amp; <code>ref</code> with function or without",id:"type--ref-with-function-or-without",level:2},{value:"<code>type</code> with array or without",id:"type-with-array-or-without",level:2},{value:"Multiple array types",id:"multiple-array-types",level:2},{value:"SubDocument types",id:"subdocument-types",level:2}];function p(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"This Page shows different possibilities of how code can be written in Typegoose, along with their use-cases and what differs between them."}),"\n",(0,r.jsxs)(t.h2,{id:"type--ref-with-function-or-without",children:[(0,r.jsx)(t.code,{children:"type"})," & ",(0,r.jsx)(t.code,{children:"ref"})," with function or without"]}),"\n",(0,r.jsxs)(t.p,{children:["The options ",(0,r.jsx)(t.a,{href:"/typegoose/docs/api/decorators/prop#type",children:(0,r.jsx)(t.code,{children:"type"})})," and ",(0,r.jsx)(t.a,{href:"/typegoose/docs/api/decorators/prop#ref",children:(0,r.jsx)(t.code,{children:"ref"})})," can be written either as ",(0,r.jsx)(t.code,{children:"type: Type"})," or as ",(0,r.jsx)(t.code,{children:"type: () => Type"}),'. Both syntax variations are valid options, but the second should always be preferred when not using primitives, because this "deferred function" syntax can workaround the issues of ',(0,r.jsx)(t.a,{href:"/typegoose/docs/guides/advanced/reference-other-classes#circular-dependencies",children:"Circular References"})," (in some cases) and also correct situations where you might run into ",(0,r.jsx)(t.code,{children:"use-before-declaration"})," errors."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"class Cat {\n  @prop({ type: String })\n  public name: string;\n\n  // is the same as\n  @prop({ type: () => String })\n  public name: string;\n}\n\nclass Cat {\n  @prop({ type: Food }) // ERROR: Used before declaration\n  public food: Food;\n\n  @prop({ type: () => Food }) // no error, thanks to the deferred function\n  public food: Food;\n}\n\nclass Food {\n  @prop({ type: String })\n  public vitamins: string;\n}\n"})}),"\n",(0,r.jsxs)(t.h2,{id:"type-with-array-or-without",children:[(0,r.jsx)(t.code,{children:"type"})," with array or without"]}),"\n",(0,r.jsxs)(t.p,{children:["When defining the ",(0,r.jsxs)(t.a,{href:"/typegoose/docs/api/decorators/prop",children:[(0,r.jsx)(t.code,{children:"type"})," in the ",(0,r.jsx)(t.code,{children:"prop options"})]})," for an array, the type can be written either as ",(0,r.jsx)(t.code,{children:"type: Type"})," or as ",(0,r.jsx)(t.code,{children:"type: [Type]"}),". Both are valid options and the differences are only cosmetic. However, if you're using more than 1 dimension, it is ",(0,r.jsx)(t.em,{children:"no longer"})," cosmetic and the type has to indicate the ",(0,r.jsx)(t.a,{href:"/typegoose/docs/api/decorators/prop#dim",children:"number of dimensions"}),". This rule is valid for both ",(0,r.jsxs)(t.a,{href:"#type--ref-with-function-or-without",children:[(0,r.jsx)(t.code,{children:"type"})," & ",(0,r.jsx)(t.code,{children:"ref"})," with function or without"]}),"."]}),"\n",(0,r.jsx)(t.admonition,{type:"note",children:(0,r.jsxs)(t.p,{children:["If dimension syntax is used in the ",(0,r.jsx)(t.code,{children:"ref"})," option, Typegoose will ",(0,r.jsx)(t.a,{href:"/typegoose/docs/guides/error-warning-details#the-option-does-not-support-a-option-value-e027",children:"throw an error"})," because only ",(0,r.jsx)(t.code,{children:"ref: Type"})," is allowed (no array)."]})}),"\n",(0,r.jsx)(t.admonition,{type:"note",children:(0,r.jsxs)(t.p,{children:["Using dimensions, while not setting the property to be an array, will ",(0,r.jsx)(t.strong,{children:"not"})," set the type to an array. Use ",(0,r.jsxs)(t.a,{href:"/typegoose/docs/api/decorators/prop",children:["the ",(0,r.jsx)(t.code,{children:"@prop"})," decorator's second parameter"]})," for that. Or alternatively, when ",(0,r.jsx)(t.a,{href:"/typegoose/docs/guides/use-without-emitDecoratorMetadata",children:(0,r.jsx)(t.code,{children:"emitDecoratorMetadata"})})," is in use and the type is set correctly, then the array type will be set automatically too."]})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:'class Cat {\n  @prop({ type: String }) // one dimensional array\n  public nickNames: string[]; // array type automatically inferred because of "emitDecoratorMetadata" reflection\n\n  // the above and below examples are the same\n  @prop({ type: [String] }) // one dimensional array\n  public nickNames: string[]; // array type automatically inferred because of "emitDecoratorMetadata" reflection\n\n  // to use more dimensions\n  @prop({ type: [[String]] }) // two-dimensional array\n  public nickNames: string[][]; // array type automatically inferred because of "emitDecoratorMetadata" reflection\n\n  @prop({ type: String }, PropType.ARRAY) // one dimensional array, explicitly set to be an array\n  public explicitArray: string[];\n}\n'})}),"\n",(0,r.jsx)(t.h2,{id:"multiple-array-types",children:"Multiple array types"}),"\n",(0,r.jsxs)(t.p,{children:["There are multiple types an array property can have, all having their use-cases, but most of the time, a simple ",(0,r.jsx)(t.code,{children:"type[]"})," or ",(0,r.jsx)(t.code,{children:"[type]"})," is enough."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:'class Cat {\n  @prop({ type: String })\n  public normalArray: string[]; // normal array, will still be a Mongoose array at runtime, but not in types\n\n  @prop({ type: String })\n  public mongooseArray: mongoose.Types.Array<string>; // Mongoose array, with Mongoose functions provided (the "normalArray" would still be this type at runtime)\n\n  // the "ArraySubDocumentType" type is provided by Typegoose\n  @prop({ type: () => Kitten })\n  public subDocArray: ArraySubDocumentType<Kitten>[]; // Mongoose subdocument array, with Mongoose subdocument functions provided\n}\n\nclass Kitten {\n  @prop()\n  public name: string;\n}\n'})}),"\n",(0,r.jsx)(t.h2,{id:"subdocument-types",children:"SubDocument types"}),"\n",(0,r.jsx)(t.p,{children:"There are special types to provide the specific Mongoose functions for subdocuments, but they can be omitted when those extra functions aren't needed."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:'class Cat {\n  @prop({ type: () => Kitten })\n  public normalSubDoc: Kitten; // normal subdocument, no extra Mongoose functions in the types\n\n  // the "SubDocumentType" type is provided by Typegoose\n  @prop({ type: () => Kitten })\n  public typedSubDoc: SubDocumentType<Kitten>; // Mongoose subdocument type, with Mongoose subdocument functions\n\n  // the "ArraySubDocumentType" type is provided by Typegoose\n  @prop({ type: () => Kitten })\n  public subDocArray: ArraySubDocumentType<Kitten>[]; // Mongoose subdocument array, with Mongoose subdocument functions provided\n}\n\nclass Kitten {\n  @prop()\n  public name: string;\n}\n'})})]})}function l(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>a});var o=n(6540);const r={},s=o.createContext(r);function i(e){const t=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);